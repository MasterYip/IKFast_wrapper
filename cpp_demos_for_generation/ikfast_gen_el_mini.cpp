/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2023-12-13 08:38:56.011944
/// Generated using solver translation3d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004a);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13;
x0=IKcos(j[1]);
x1=IKsin(j[0]);
x2=IKsin(j[2]);
x3=IKsin(j[1]);
x4=IKcos(j[2]);
x5=IKcos(j[0]);
x6=((8.5e-7)*x2);
x7=((0.232)*x4);
x8=((8.5e-7)*x4);
x9=((0.232)*x2);
x10=(x1*x3);
x11=(x3*x5);
x12=(x0*x1);
x13=(x0*x5);
eetrans[0]=((0.3)+(((0.13)*x10))+(((0.0535)*x5))+(((-1.0)*x10*x7))+(((9.6e-7)*x12))+((x10*x6))+((x12*x9))+((x12*x8))+(((0.14999)*x1)));
IkReal x14=((1.0)*x13);
eetrans[1]=((-0.08)+(((-9.6e-7)*x13))+(((0.0535)*x1))+(((-0.14999)*x5))+(((-1.0)*x11*x6))+((x11*x7))+(((-0.13)*x11))+(((-1.0)*x14*x9))+(((-1.0)*x14*x8)));
IkReal x15=((1.0)*x3);
eetrans[2]=((-0.034056)+((x0*x6))+(((-1.0)*x15*x9))+(((-1.0)*x15*x8))+(((-9.6e-7)*x3))+(((-1.0)*x0*x7))+(((0.13)*x0)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 3; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x33000003; }

class IKSolver {
public:
IkReal j15,cj15,sj15,htj15,j15mul,j16,cj16,sj16,htj16,j16mul,j17,cj17,sj17,htj17,j17mul,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij15[2], _nj15,_ij16[2], _nj16,_ij17[2], _nj17;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j15=numeric_limits<IkReal>::quiet_NaN(); _ij15[0] = -1; _ij15[1] = -1; _nj15 = -1; j16=numeric_limits<IkReal>::quiet_NaN(); _ij16[0] = -1; _ij16[1] = -1; _nj16 = -1; j17=numeric_limits<IkReal>::quiet_NaN(); _ij17[0] = -1; _ij17[1] = -1; _nj17 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_px=((-0.3)+px);
new_py=((0.08)+py);
new_pz=((0.034056)+pz);
px = new_px; py = new_py; pz = new_pz;
pp=((px*px)+(py*py)+(pz*pz));
{
IkReal j15eval[2];
j15eval[0]=((px*px)+(py*py));
j15eval[1]=((IKabs(px))+(IKabs(py)));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j17array[2], cj17array[2], sj17array[2];
bool j17valid[2]={false};
_nj17 = 2;
if( (((0.84697032327434)+(((-16.5782493363067)*(pz*pz))))) < -1-IKFAST_SINCOS_THRESH || (((0.84697032327434)+(((-16.5782493363067)*(pz*pz))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x16=IKasin(((0.84697032327434)+(((-16.5782493363067)*(pz*pz)))));
j17array[0]=((1.57078527838641)+(((-1.0)*x16)));
sj17array[0]=IKsin(j17array[0]);
cj17array[0]=IKcos(j17array[0]);
j17array[1]=((4.7123779319762)+x16);
sj17array[1]=IKsin(j17array[1]);
cj17array[1]=IKcos(j17array[1]);
if( j17array[0] > IKPI )
{
    j17array[0]-=IK2PI;
}
else if( j17array[0] < -IKPI )
{    j17array[0]+=IK2PI;
}
j17valid[0] = true;
if( j17array[1] > IKPI )
{
    j17array[1]-=IK2PI;
}
else if( j17array[1] < -IKPI )
{    j17array[1]+=IK2PI;
}
j17valid[1] = true;
for(int ij17 = 0; ij17 < 2; ++ij17)
{
if( !j17valid[ij17] )
{
    continue;
}
_ij17[0] = ij17; _ij17[1] = -1;
for(int iij17 = ij17+1; iij17 < 2; ++iij17)
{
if( j17valid[iij17] && IKabs(cj17array[ij17]-cj17array[iij17]) < IKFAST_SOLUTION_THRESH && IKabs(sj17array[ij17]-sj17array[iij17]) < IKFAST_SOLUTION_THRESH )
{
    j17valid[iij17]=false; _ij17[1] = iij17; break; 
}
}
j17 = j17array[ij17]; cj17 = cj17array[ij17]; sj17 = sj17array[ij17];

{
IkReal j16eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x17=pz*pz;
IkReal x18=((8500.0)*pz);
IkReal x19=((2320000000.0)*pz);
j16eval[0]=((1.0)+(((44.4503709630156)*x17)));
j16eval[1]=IKsign(((224970001.0)+(((10000000000.0)*x17))));
j16eval[2]=((IKabs(((-194987000.0)+(((-1274.915)*sj17))+(((-1.0)*cj17*x18))+(((-1.0)*sj17*x19))+(((-9600.0)*pz))+(((347976800.0)*cj17)))))+(IKabs(((-1439.904)+(((-347976800.0)*sj17))+(((-1.0)*cj17*x19))+(((-1274.915)*cj17))+((sj17*x18))+(((1300000000.0)*pz))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x20=cj17*cj17;
IkReal x21=(pz*sj17);
IkReal x22=(cj17*sj17);
IkReal x23=(cj17*pz);
j16eval[0]=((-152941.176470588)+(((6.66711114074272)*x23))+(((272941.176470588)*cj17))+(((-1.0)*sj17))+(((1819729.15841448)*x21))+(((7.52991375895648)*pz)));
j16eval[1]=IKsign(((-1949.87)+(((23200.0)*x21))+(((3479.768)*cj17))+(((-0.01274915)*sj17))+(((0.085)*x23))+(((0.096)*pz))));
j16eval[2]=((IKabs(((1690.00000007225)+(((5382.39999992775)*x20))+(((-6032.0)*cj17))+(((-0.03944)*x22))+(((-100000.0)*(pz*pz)))+(((0.0221)*sj17)))))+(IKabs(((0.0322)+(((3016.0000000816)*sj17))+(((-0.03944)*x20))+(((-0.011222)*cj17))+(((-5382.39999992775)*x22))+(((-14999.0)*pz))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x24=cj17*cj17;
IkReal x25=(cj17*pz);
IkReal x26=(pz*sj17);
IkReal x27=(cj17*sj17);
j16eval[0]=((-1.12941176470588)+(((-1019675.82152536)*pz))+(((-272941.176470588)*sj17))+(((1819729.15841448)*x25))+(((-1.0)*cj17))+(((-6.66711114074272)*x26)));
j16eval[1]=IKsign(((-0.01439904)+(((23200.0)*x25))+(((-13000.0)*pz))+(((-3479.768)*sj17))+(((-0.01274915)*cj17))+(((-0.085)*x26))));
j16eval[2]=((IKabs(((0.0322)+(((3016.0000000816)*sj17))+(((-0.03944)*x24))+(((-0.011222)*cj17))+(((-5382.39999992775)*x27))+(((14999.0)*pz)))))+(IKabs(((5382.40000009216)+(((0.044544)*sj17))+(((-100000.0)*(pz*pz)))+(((-5382.39999992775)*x24))+(((1.632e-7)*cj17))+(((0.03944)*x27))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j15, j16]

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x28=cj17*cj17;
IkReal x29=(cj17*sj17);
CheckValue<IkReal> x30 = IKatan2WithCheck(IkReal(((0.0322)+(((3016.0000000816)*sj17))+(((-0.03944)*x28))+(((-0.011222)*cj17))+(((-5382.39999992775)*x29))+(((14999.0)*pz)))),IkReal(((5382.40000009216)+(((0.044544)*sj17))+(((-100000.0)*(pz*pz)))+(((-5382.39999992775)*x28))+(((1.632e-7)*cj17))+(((0.03944)*x29)))),IKFAST_ATAN2_MAGTHRESH);
if(!x30.valid){
continue;
}
CheckValue<IkReal> x31=IKPowWithIntegerCheck(IKsign(((-0.01439904)+(((23200.0)*cj17*pz))+(((-0.085)*pz*sj17))+(((-13000.0)*pz))+(((-3479.768)*sj17))+(((-0.01274915)*cj17)))),-1);
if(!x31.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x30.value)+(((1.5707963267949)*(x31.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x32=IKcos(j16);
IkReal x33=IKsin(j16);
IkReal x34=((0.232)*cj17);
IkReal x35=((0.232)*sj17);
IkReal x36=((8.5e-7)*sj17);
IkReal x37=((8.5e-7)*cj17);
IkReal x38=((8.5e-7)*x33);
IkReal x39=(pz*x33);
IkReal x40=(pz*x32);
evalcond[0]=((-0.13)+(((-1.0)*x36))+x34+x40+(((-0.14999)*x33)));
evalcond[1]=((9.6e-7)+(((0.14999)*x32))+x39+x37+x35);
evalcond[2]=((0.0172892498998009)+(((0.26)*x40))+(((-2.879808e-7)*x32))+(((-1.0)*(pz*pz)))+(((-0.0389974)*x33))+(((-1.92e-6)*x39)));
evalcond[3]=((((-1.0)*x32*x36))+(((9.6e-7)*x33))+(((-0.13)*x32))+pz+((x32*x34))+((x33*x37))+((x33*x35)));
evalcond[4]=((-0.14999)+(((-1.0)*x32*x37))+(((-1.0)*x32*x35))+(((-9.6e-7)*x32))+(((-0.13)*x33))+(((-1.0)*x33*x36))+((x33*x34)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
j15array[0]=0;
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x41=cj17*cj17;
IkReal x42=(cj17*sj17);
CheckValue<IkReal> x43 = IKatan2WithCheck(IkReal(((1690.00000007225)+(((-6032.0)*cj17))+(((-100000.0)*(pz*pz)))+(((5382.39999992775)*x41))+(((-0.03944)*x42))+(((0.0221)*sj17)))),IkReal(((0.0322)+(((3016.0000000816)*sj17))+(((-0.011222)*cj17))+(((-5382.39999992775)*x42))+(((-0.03944)*x41))+(((-14999.0)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x43.valid){
continue;
}
CheckValue<IkReal> x44=IKPowWithIntegerCheck(IKsign(((-1949.87)+(((23200.0)*pz*sj17))+(((3479.768)*cj17))+(((-0.01274915)*sj17))+(((0.085)*cj17*pz))+(((0.096)*pz)))),-1);
if(!x44.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x43.value)+(((1.5707963267949)*(x44.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x45=IKcos(j16);
IkReal x46=IKsin(j16);
IkReal x47=((0.232)*cj17);
IkReal x48=((0.232)*sj17);
IkReal x49=((8.5e-7)*sj17);
IkReal x50=((8.5e-7)*cj17);
IkReal x51=((8.5e-7)*x46);
IkReal x52=(pz*x46);
IkReal x53=(pz*x45);
evalcond[0]=((-0.13)+(((-1.0)*x49))+(((-0.14999)*x46))+x47+x53);
evalcond[1]=((9.6e-7)+x48+x50+x52+(((0.14999)*x45)));
evalcond[2]=((0.0172892498998009)+(((-2.879808e-7)*x45))+(((-1.92e-6)*x52))+(((-1.0)*(pz*pz)))+(((-0.0389974)*x46))+(((0.26)*x53)));
evalcond[3]=(((x46*x48))+(((-1.0)*x45*x49))+(((9.6e-7)*x46))+(((-0.13)*x45))+pz+((x45*x47))+((x46*x50)));
evalcond[4]=((-0.14999)+(((-1.0)*x45*x50))+((x46*x47))+(((-1.0)*x45*x48))+(((-9.6e-7)*x45))+(((-0.13)*x46))+(((-1.0)*x46*x49)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
j15array[0]=0;
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x54=((8500.0)*pz);
IkReal x55=((2320000000.0)*pz);
CheckValue<IkReal> x56=IKPowWithIntegerCheck(IKsign(((224970001.0)+(((10000000000.0)*(pz*pz))))),-1);
if(!x56.valid){
continue;
}
CheckValue<IkReal> x57 = IKatan2WithCheck(IkReal(((-194987000.0)+(((-1.0)*cj17*x54))+(((-1274.915)*sj17))+(((-1.0)*sj17*x55))+(((-9600.0)*pz))+(((347976800.0)*cj17)))),IkReal(((-1439.904)+(((-1.0)*cj17*x55))+((sj17*x54))+(((-347976800.0)*sj17))+(((-1274.915)*cj17))+(((1300000000.0)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x57.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x56.value)))+(x57.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x58=IKcos(j16);
IkReal x59=IKsin(j16);
IkReal x60=((0.232)*cj17);
IkReal x61=((0.232)*sj17);
IkReal x62=((8.5e-7)*sj17);
IkReal x63=((8.5e-7)*cj17);
IkReal x64=((8.5e-7)*x59);
IkReal x65=(pz*x59);
IkReal x66=(pz*x58);
evalcond[0]=((-0.13)+x60+x66+(((-0.14999)*x59))+(((-1.0)*x62)));
evalcond[1]=((9.6e-7)+(((0.14999)*x58))+x61+x63+x65);
evalcond[2]=((0.0172892498998009)+(((-2.879808e-7)*x58))+(((-1.92e-6)*x65))+(((-0.0389974)*x59))+(((-1.0)*(pz*pz)))+(((0.26)*x66)));
evalcond[3]=(((x59*x63))+((x59*x61))+((x58*x60))+(((9.6e-7)*x59))+pz+(((-1.0)*x58*x62))+(((-0.13)*x58)));
evalcond[4]=((-0.14999)+((x59*x60))+(((-1.0)*x59*x62))+(((-1.0)*x58*x63))+(((-1.0)*x58*x61))+(((-9.6e-7)*x58))+(((-0.13)*x59)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
j15array[0]=0;
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j17array[2], cj17array[2], sj17array[2];
bool j17valid[2]={false};
_nj17 = 2;
if( (((0.84697032327434)+(((-16.5782493363067)*(pz*pz))))) < -1-IKFAST_SINCOS_THRESH || (((0.84697032327434)+(((-16.5782493363067)*(pz*pz))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x67=IKasin(((0.84697032327434)+(((-16.5782493363067)*(pz*pz)))));
j17array[0]=((1.57078527838641)+(((-1.0)*x67)));
sj17array[0]=IKsin(j17array[0]);
cj17array[0]=IKcos(j17array[0]);
j17array[1]=((4.7123779319762)+x67);
sj17array[1]=IKsin(j17array[1]);
cj17array[1]=IKcos(j17array[1]);
if( j17array[0] > IKPI )
{
    j17array[0]-=IK2PI;
}
else if( j17array[0] < -IKPI )
{    j17array[0]+=IK2PI;
}
j17valid[0] = true;
if( j17array[1] > IKPI )
{
    j17array[1]-=IK2PI;
}
else if( j17array[1] < -IKPI )
{    j17array[1]+=IK2PI;
}
j17valid[1] = true;
for(int ij17 = 0; ij17 < 2; ++ij17)
{
if( !j17valid[ij17] )
{
    continue;
}
_ij17[0] = ij17; _ij17[1] = -1;
for(int iij17 = ij17+1; iij17 < 2; ++iij17)
{
if( j17valid[iij17] && IKabs(cj17array[ij17]-cj17array[iij17]) < IKFAST_SOLUTION_THRESH && IKabs(sj17array[ij17]-sj17array[iij17]) < IKFAST_SOLUTION_THRESH )
{
    j17valid[iij17]=false; _ij17[1] = iij17; break; 
}
}
j17 = j17array[ij17]; cj17 = cj17array[ij17]; sj17 = sj17array[ij17];

{
IkReal j16eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x68=pz*pz;
IkReal x69=((8500.0)*pz);
IkReal x70=((2320000000.0)*pz);
j16eval[0]=((1.0)+(((44.4503709630156)*x68)));
j16eval[1]=IKsign(((224970001.0)+(((10000000000.0)*x68))));
j16eval[2]=((IKabs(((-1439.904)+((sj17*x69))+(((-347976800.0)*sj17))+(((-1274.915)*cj17))+(((-1.0)*cj17*x70))+(((1300000000.0)*pz)))))+(IKabs(((-194987000.0)+(((-1.0)*cj17*x69))+(((-1274.915)*sj17))+(((-1.0)*sj17*x70))+(((-9600.0)*pz))+(((347976800.0)*cj17))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x71=cj17*cj17;
IkReal x72=(pz*sj17);
IkReal x73=(cj17*sj17);
IkReal x74=(cj17*pz);
j16eval[0]=((-152941.176470588)+(((1819729.15841448)*x72))+(((272941.176470588)*cj17))+(((-1.0)*sj17))+(((7.52991375895648)*pz))+(((6.66711114074272)*x74)));
j16eval[1]=IKsign(((-1949.87)+(((23200.0)*x72))+(((3479.768)*cj17))+(((-0.01274915)*sj17))+(((0.096)*pz))+(((0.085)*x74))));
j16eval[2]=((IKabs(((1690.00000007225)+(((5382.39999992775)*x71))+(((-6032.0)*cj17))+(((-100000.0)*(pz*pz)))+(((-0.03944)*x73))+(((0.0221)*sj17)))))+(IKabs(((0.0322)+(((3016.0000000816)*sj17))+(((-5382.39999992775)*x73))+(((-0.011222)*cj17))+(((-0.03944)*x71))+(((-14999.0)*pz))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x75=cj17*cj17;
IkReal x76=(cj17*pz);
IkReal x77=(pz*sj17);
IkReal x78=(cj17*sj17);
j16eval[0]=((-1.12941176470588)+(((1819729.15841448)*x76))+(((-1019675.82152536)*pz))+(((-6.66711114074272)*x77))+(((-272941.176470588)*sj17))+(((-1.0)*cj17)));
j16eval[1]=IKsign(((-0.01439904)+(((23200.0)*x76))+(((-13000.0)*pz))+(((-3479.768)*sj17))+(((-0.085)*x77))+(((-0.01274915)*cj17))));
j16eval[2]=((IKabs(((5382.40000009216)+(((0.044544)*sj17))+(((-5382.39999992775)*x75))+(((0.03944)*x78))+(((-100000.0)*(pz*pz)))+(((1.632e-7)*cj17)))))+(IKabs(((0.0322)+(((3016.0000000816)*sj17))+(((-5382.39999992775)*x78))+(((-0.011222)*cj17))+(((-0.03944)*x75))+(((14999.0)*pz))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x79=((-272941.176470588)+(((-6.66711114074272)*pz)));
IkReal x80=((-1.12941176470588)+(((-1019675.82152536)*pz)));
IkReal x81=((-1.0)+(((1819729.15841448)*pz)));
IkReal x82=x80*x80;
IkReal x83=((x81*x81)+(x79*x79));
if((((74496885814.1488)+(((3311414210028.33)*(pz*pz))))) < -0.00001)
continue;
IkReal x84=IKabs(IKsqrt(((74496885814.1488)+(((3311414210028.33)*(pz*pz))))));
CheckValue<IkReal> x92=IKPowWithIntegerCheck(x84,-1);
if(!x92.valid){
continue;
}
IkReal x85=x92.value;
CheckValue<IkReal> x93=IKPowWithIntegerCheck(x84,-2);
if(!x93.valid){
continue;
}
IkReal x86=x93.value;
IkReal x87=(x80*x85);
IkReal x94 = x83;
if(IKabs(x94)==0){
continue;
}
IkReal x88=pow(x94,-0.5);
IkReal x89=((1.0)*x88);
IkReal x90=(x79*x88);
IkReal x91=(x82*x86);
CheckValue<IkReal> x95 = IKatan2WithCheck(IkReal(x81),IkReal(x79),IKFAST_ATAN2_MAGTHRESH);
if(!x95.valid){
continue;
}
if((x83) < -0.00001)
continue;
CheckValue<IkReal> x96=IKPowWithIntegerCheck(IKabs(IKsqrt(x83)),-1);
if(!x96.valid){
continue;
}
if( (((1.0)*x80*(x96.value))) < -1-IKFAST_SINCOS_THRESH || (((1.0)*x80*(x96.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst0=((((-1.0)*(x95.value)))+(((-1.0)*(IKasin(((1.0)*x80*(x96.value)))))));
if((((1.0)+(((-1.0)*x91)))) < -0.00001)
continue;
IkReal gconst1=((((-1.0)*x79*x87*x89))+(((-1.0)*x81*x89*(IKsqrt(((1.0)+(((-1.0)*x91))))))));
if((((1.0)+(((-1.0)*x91)))) < -0.00001)
continue;
IkReal gconst2=(((x90*(IKsqrt(((1.0)+(((-1.0)*x91)))))))+(((-1.0)*x81*x87*x89)));
IkReal x97=x79;
IkReal x98=((-1.0)+(((1819729.15841448)*pz)));
CheckValue<IkReal> x99 = IKatan2WithCheck(IkReal(x98),IkReal(x97),IKFAST_ATAN2_MAGTHRESH);
if(!x99.valid){
continue;
}
if((((x97*x97)+(x98*x98))) < -0.00001)
continue;
CheckValue<IkReal> x100=IKPowWithIntegerCheck(IKabs(IKsqrt(((x97*x97)+(x98*x98)))),-1);
if(!x100.valid){
continue;
}
if( (((-1.0)*(x100.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x100.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x101 = IKatan2WithCheck(IkReal(x98),IkReal(x97),IKFAST_ATAN2_MAGTHRESH);
if(!x101.valid){
continue;
}
if((((x97*x97)+(x98*x98))) < -0.00001)
continue;
CheckValue<IkReal> x102=IKPowWithIntegerCheck(IKabs(IKsqrt(((x97*x97)+(x98*x98)))),-1);
if(!x102.valid){
continue;
}
if( (((-1.0)*(x102.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x102.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x97*x97)+(x98*x98))) < -0.00001)
continue;
CheckValue<IkReal> x103=IKPowWithIntegerCheck(IKabs(IKsqrt(((x97*x97)+(x98*x98)))),-1);
if(!x103.valid){
continue;
}
if( (((-1.0)*(x103.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x103.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x104 = IKatan2WithCheck(IkReal(x98),IkReal(x97),IKFAST_ATAN2_MAGTHRESH);
if(!x104.valid){
continue;
}
CheckValue<IkReal> x105 = IKatan2WithCheck(IkReal(x98),IkReal(x97),IKFAST_ATAN2_MAGTHRESH);
if(!x105.valid){
continue;
}
CheckValue<IkReal> x106 = IKatan2WithCheck(IkReal(x98),IkReal(x97),IKFAST_ATAN2_MAGTHRESH);
if(!x106.valid){
continue;
}
if((((x97*x97)+(x98*x98))) < -0.00001)
continue;
CheckValue<IkReal> x107=IKPowWithIntegerCheck(IKabs(IKsqrt(((x97*x97)+(x98*x98)))),-1);
if(!x107.valid){
continue;
}
if( (((-1.0)*(x107.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x107.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x108 = IKatan2WithCheck(IkReal(x98),IkReal(x97),IKFAST_ATAN2_MAGTHRESH);
if(!x108.valid){
continue;
}
if((((x97*x97)+(x98*x98))) < -0.00001)
continue;
CheckValue<IkReal> x109=IKPowWithIntegerCheck(IKabs(IKsqrt(((x97*x97)+(x98*x98)))),-1);
if(!x109.valid){
continue;
}
if( (((-1.0)*(x109.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x109.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x97*x97)+(x98*x98))) < -0.00001)
continue;
CheckValue<IkReal> x110=IKPowWithIntegerCheck(IKabs(IKsqrt(((x97*x97)+(x98*x98)))),-1);
if(!x110.valid){
continue;
}
if( (((-1.0)*(x110.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x110.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((((x99.value)*(j17)))+(((-1.0)*(IKasin(((-1.0)*(x100.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))))*(x101.value)))+(((-1.0)*j17*(IKasin(((-1.0)*(x102.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))))))+((j17*(j17)))+(((-1.0)*(IKasin(((-1.0)*(x103.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))))*(j17)))+(((x104.value)*(x105.value)))+(((-1.0)*(x106.value)*(IKasin(((-1.0)*(x107.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))))))+((j17*(x108.value)))+(((1.0)*(IKasin(((-1.0)*(x109.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))))*(IKasin(((-1.0)*(x110.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz))))))))))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt(((((x99.value)*(j17)))+(((-1.0)*(IKasin(((-1.0)*(x100.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))))*(x101.value)))+(((-1.0)*j17*(IKasin(((-1.0)*(x102.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))))))+((j17*(j17)))+(((-1.0)*(IKasin(((-1.0)*(x103.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))))*(j17)))+(((x104.value)*(x105.value)))+(((-1.0)*(x106.value)*(IKasin(((-1.0)*(x107.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))))))+((j17*(x108.value)))+(((1.0)*(IKasin(((-1.0)*(x109.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz)))))))*(IKasin(((-1.0)*(x110.value)*(((-1.12941176470588)+(((-1019675.82152536)*pz))))))))))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[2];
IkReal x111=((6.66711114074272)*pz);
IkReal x112=((-272941.176470588)+(((-1.0)*x111)));
IkReal x113=pz*pz;
IkReal x114=x80;
IkReal x115=((-1.0)+(((1819729.15841448)*pz)));
IkReal x116=x114*x114;
IkReal x117=((x112*x112)+(x115*x115));
IkReal x118=x84;
CheckValue<IkReal> x128=IKPowWithIntegerCheck(x118,-1);
if(!x128.valid){
continue;
}
IkReal x119=x128.value;
CheckValue<IkReal> x129=IKPowWithIntegerCheck(x118,-2);
if(!x129.valid){
continue;
}
IkReal x120=x129.value;
IkReal x121=(x114*x119);
IkReal x130 = x117;
if(IKabs(x130)==0){
continue;
}
IkReal x122=pow(x130,-0.5);
IkReal x123=((1.0)*x122);
if((x117) < -0.00001)
continue;
CheckValue<IkReal> x131=IKPowWithIntegerCheck(IKabs(IKsqrt(x117)),-1);
if(!x131.valid){
continue;
}
IkReal x124=x131.value;
IkReal x125=(x116*x120);
IkReal x126=(x112*x122);
IkReal x127=((1.0)*x124);
px=0;
py=0;
pp=x113;
sj17=gconst1;
cj17=gconst2;
if( (((-1.0)*x127*(((-1.12941176)+(((-1020408.16326531)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*x127*(((-1.12941176)+(((-1020408.16326531)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x132 = IKatan2WithCheck(IkReal(((-1.0)+(((1818181.81818182)*pz)))),IkReal(((-273224.043715847)+(((-1.0)*x111)))),IKFAST_ATAN2_MAGTHRESH);
if(!x132.valid){
continue;
}
j17=((IKasin(((-1.0)*x127*(((-1.12941176)+(((-1020408.16326531)*pz)))))))+(((-1.0)*(x132.value))));
CheckValue<IkReal> x133 = IKatan2WithCheck(IkReal(x115),IkReal(x112),IKFAST_ATAN2_MAGTHRESH);
if(!x133.valid){
continue;
}
if( ((x114*x127)) < -1-IKFAST_SINCOS_THRESH || ((x114*x127)) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst0=((((-1.0)*(x133.value)))+(((-1.0)*(IKasin((x114*x127))))));
if((((1.0)+(((-1.0)*x125)))) < -0.00001)
continue;
IkReal gconst1=((((-1.0)*x115*x123*(IKsqrt(((1.0)+(((-1.0)*x125)))))))+(((-1.0)*x112*x121*x123)));
if((((1.0)+(((-1.0)*x125)))) < -0.00001)
continue;
IkReal gconst2=(((x126*(IKsqrt(((1.0)+(((-1.0)*x125)))))))+(((-1.0)*x115*x121*x123)));
IkReal x134=pz*pz;
j16eval[0]=((1.0)+(((44.4503709630156)*x134)));
j16eval[1]=IKsign(((224970001.0)+(((10000000000.0)*x134))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x135=gconst1*gconst1;
IkReal x136=gconst2*gconst2;
IkReal x137=(gconst1*gconst2);
CheckValue<IkReal> x138=IKPowWithIntegerCheck(IKsign(((-1949.87)+(((3479.768)*gconst2))+(((-0.01274915)*gconst1))+(((0.096)*pz))+(((23200.0)*gconst1*pz))+(((0.085)*gconst2*pz)))),-1);
if(!x138.valid){
continue;
}
CheckValue<IkReal> x139 = IKatan2WithCheck(IkReal(((1690.0)+(((0.0221)*gconst1))+(((-6032.0)*gconst2))+(((-0.03944)*x137))+(((5382.4)*x136))+(((7.225e-8)*x135))+(((-100000.0)*(pz*pz))))),IkReal(((0.01248)+(((3016.0000000816)*gconst1))+(((-0.011222)*gconst2))+(((-0.01972)*x136))+(((-5382.39999992775)*x137))+(((0.01972)*x135))+(((-14999.0)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x139.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x138.value)))+(x139.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x140=IKcos(j16);
IkReal x141=IKsin(j16);
IkReal x142=((8.5e-7)*gconst1);
IkReal x143=((0.232)*gconst1);
IkReal x144=((8.5e-7)*gconst2);
IkReal x145=((0.232)*gconst2);
IkReal x146=(pz*x141);
IkReal x147=(pz*x140);
evalcond[0]=((-0.13)+(((-1.0)*x142))+x145+x147+(((-0.14999)*x141)));
evalcond[1]=((9.6e-7)+(((0.14999)*x140))+x143+x144+x146);
evalcond[2]=((0.0172892498998009)+(((0.26)*x147))+(((-0.0389974)*x141))+(((-1.92e-6)*x146))+(((-2.879808e-7)*x140))+(((-1.0)*(pz*pz))));
evalcond[3]=(((x140*x145))+(((-1.0)*x140*x142))+((x141*x144))+((x141*x143))+pz+(((-0.13)*x140))+(((9.6e-7)*x141)));
evalcond[4]=((-0.14999)+(((-1.0)*x140*x143))+(((-1.0)*x140*x144))+((x141*x145))+(((-0.13)*x141))+(((-1.0)*x141*x142))+(((-9.6e-7)*x140)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
j15array[0]=0;
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x148=(gconst2*pz);
IkReal x149=(gconst1*pz);
CheckValue<IkReal> x150=IKPowWithIntegerCheck(IKsign(((224970001.0)+(((10000000000.0)*(pz*pz))))),-1);
if(!x150.valid){
continue;
}
CheckValue<IkReal> x151 = IKatan2WithCheck(IkReal(((-194987000.0)+(((347976800.0)*gconst2))+(((-8500.0)*x148))+(((-9600.0)*pz))+(((-2320000000.0)*x149))+(((-1274.915)*gconst1)))),IkReal(((-1439.904)+(((8500.0)*x149))+(((-347976800.0)*gconst1))+(((-2320000000.0)*x148))+(((1300000000.0)*pz))+(((-1274.915)*gconst2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x151.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x150.value)))+(x151.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x152=IKcos(j16);
IkReal x153=IKsin(j16);
IkReal x154=((8.5e-7)*gconst1);
IkReal x155=((0.232)*gconst1);
IkReal x156=((8.5e-7)*gconst2);
IkReal x157=((0.232)*gconst2);
IkReal x158=(pz*x153);
IkReal x159=(pz*x152);
evalcond[0]=((-0.13)+(((-0.14999)*x153))+(((-1.0)*x154))+x157+x159);
evalcond[1]=((9.6e-7)+(((0.14999)*x152))+x156+x155+x158);
evalcond[2]=((0.0172892498998009)+(((0.26)*x159))+(((-0.0389974)*x153))+(((-2.879808e-7)*x152))+(((-1.92e-6)*x158))+(((-1.0)*(pz*pz))));
evalcond[3]=(((x153*x156))+((x153*x155))+((x152*x157))+(((-1.0)*x152*x154))+(((-0.13)*x152))+pz+(((9.6e-7)*x153)));
evalcond[4]=((-0.14999)+((x153*x157))+(((-1.0)*x153*x154))+(((-1.0)*x152*x155))+(((-1.0)*x152*x156))+(((-0.13)*x153))+(((-9.6e-7)*x152)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
j15array[0]=0;
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x160=((-272941.176470588)+(((-6.66711114074272)*pz)));
IkReal x161=((-1.12941176470588)+(((-1019675.82152536)*pz)));
IkReal x162=((-1.0)+(((1819729.15841448)*pz)));
IkReal x163=x161*x161;
IkReal x164=((1.0)*x161);
IkReal x165=((x160*x160)+(x162*x162));
if((((74496885814.1488)+(((3311414210028.33)*(pz*pz))))) < -0.00001)
continue;
IkReal x166=IKabs(IKsqrt(((74496885814.1488)+(((3311414210028.33)*(pz*pz))))));
CheckValue<IkReal> x173=IKPowWithIntegerCheck(x166,-1);
if(!x173.valid){
continue;
}
IkReal x167=x173.value;
CheckValue<IkReal> x174=IKPowWithIntegerCheck(x166,-2);
if(!x174.valid){
continue;
}
IkReal x168=x174.value;
IkReal x169=(x161*x167);
IkReal x175 = x165;
if(IKabs(x175)==0){
continue;
}
IkReal x170=pow(x175,-0.5);
IkReal x171=((1.0)*x170);
IkReal x172=(x163*x168);
if((x165) < -0.00001)
continue;
CheckValue<IkReal> x176=IKPowWithIntegerCheck(IKabs(IKsqrt(x165)),-1);
if(!x176.valid){
continue;
}
if( ((x164*(x176.value))) < -1-IKFAST_SINCOS_THRESH || ((x164*(x176.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x177 = IKatan2WithCheck(IkReal(x162),IkReal(x160),IKFAST_ATAN2_MAGTHRESH);
if(!x177.valid){
continue;
}
IkReal gconst3=((3.14159265358979)+(((1.0)*(IKasin((x164*(x176.value))))))+(((-1.0)*(x177.value))));
if((((1.0)+(((-1.0)*x172)))) < -0.00001)
continue;
IkReal gconst4=(((x162*x171*(IKsqrt(((1.0)+(((-1.0)*x172)))))))+(((-1.0)*x160*x164*x167*x170)));
if((((1.0)+(((-1.0)*x172)))) < -0.00001)
continue;
IkReal gconst5=((((-1.0)*x162*x164*x167*x170))+(((-1.0)*x160*x171*(IKsqrt(((1.0)+(((-1.0)*x172))))))));
IkReal x178=j17;
CheckValue<IkReal> x184 = IKatan2WithCheck(IkReal(((-1.0)+(((1819729.15841448)*pz)))),IkReal(((-272941.176470588)+(((-6.66711114074272)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x184.valid){
continue;
}
IkReal x179=x184.value;
IkReal x180=x179;
if((((74496885814.1488)+(((3311414210028.33)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x185=IKPowWithIntegerCheck(IKabs(IKsqrt(((74496885814.1488)+(((3311414210028.33)*(pz*pz)))))),-1);
if(!x185.valid){
continue;
}
IkReal x181=x185.value;
if( (((((1019675.82152536)*pz*x181))+(((1.12941176470588)*x181)))) < -1-IKFAST_SINCOS_THRESH || (((((1019675.82152536)*pz*x181))+(((1.12941176470588)*x181)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x182=IKasin(((((1019675.82152536)*pz*x181))+(((1.12941176470588)*x181))));
IkReal x183=x182;
if((((9.86960440108936)+((x180*x182))+((j17*x183))+((j17*x180))+((x178*x182))+((x178*x179))+((j17*x178))+((x179*x183))+((x179*x180))+(((-3.14159265358979)*j17))+(((-3.14159265358979)*x179))+(((-3.14159265358979)*x178))+((x182*x183))+(((-3.14159265358979)*x182))+(((-3.14159265358979)*x183))+(((-3.14159265358979)*x180)))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt(((9.86960440108936)+((x180*x182))+((j17*x183))+((j17*x180))+((x178*x182))+((x178*x179))+((j17*x178))+((x179*x183))+((x179*x180))+(((-3.14159265358979)*j17))+(((-3.14159265358979)*x179))+(((-3.14159265358979)*x178))+((x182*x183))+(((-3.14159265358979)*x182))+(((-3.14159265358979)*x183))+(((-3.14159265358979)*x180)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[2];
IkReal x186=((6.66711114074272)*pz);
IkReal x187=((-272941.176470588)+(((-1.0)*x186)));
IkReal x188=pz*pz;
IkReal x189=x161;
IkReal x190=((-1.0)+(((1819729.15841448)*pz)));
IkReal x191=x189*x189;
IkReal x192=((1.0)*x189);
IkReal x193=((x187*x187)+(x190*x190));
IkReal x194=x166;
CheckValue<IkReal> x203=IKPowWithIntegerCheck(x194,-1);
if(!x203.valid){
continue;
}
IkReal x195=x203.value;
CheckValue<IkReal> x204=IKPowWithIntegerCheck(x194,-2);
if(!x204.valid){
continue;
}
IkReal x196=x204.value;
IkReal x197=(x189*x195);
IkReal x205 = x193;
if(IKabs(x205)==0){
continue;
}
IkReal x198=pow(x205,-0.5);
IkReal x199=((1.0)*x198);
if((x193) < -0.00001)
continue;
CheckValue<IkReal> x206=IKPowWithIntegerCheck(IKabs(IKsqrt(x193)),-1);
if(!x206.valid){
continue;
}
IkReal x200=x206.value;
IkReal x201=((1.0)*x200);
IkReal x202=(x191*x196);
px=0;
py=0;
pp=x188;
sj17=gconst4;
cj17=gconst5;
CheckValue<IkReal> x207 = IKatan2WithCheck(IkReal(((-1.0)+(((1818181.81818182)*pz)))),IkReal(((-273224.043715847)+(((-1.0)*x186)))),IKFAST_ATAN2_MAGTHRESH);
if(!x207.valid){
continue;
}
if( (((-1.0)*x201*(((-1.12941176)+(((-1020408.16326531)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*x201*(((-1.12941176)+(((-1020408.16326531)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j17=((3.14159265)+(((-1.0)*(x207.value)))+(((-1.0)*(IKasin(((-1.0)*x201*(((-1.12941176)+(((-1020408.16326531)*pz))))))))));
if( ((x192*x200)) < -1-IKFAST_SINCOS_THRESH || ((x192*x200)) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x208 = IKatan2WithCheck(IkReal(x190),IkReal(x187),IKFAST_ATAN2_MAGTHRESH);
if(!x208.valid){
continue;
}
IkReal gconst3=((3.14159265358979)+(((1.0)*(IKasin((x192*x200)))))+(((-1.0)*(x208.value))));
if((((1.0)+(((-1.0)*x202)))) < -0.00001)
continue;
IkReal gconst4=(((x190*x199*(IKsqrt(((1.0)+(((-1.0)*x202)))))))+(((-1.0)*x187*x192*x195*x198)));
if((((1.0)+(((-1.0)*x202)))) < -0.00001)
continue;
IkReal gconst5=((((-1.0)*x190*x192*x195*x198))+(((-1.0)*x187*x199*(IKsqrt(((1.0)+(((-1.0)*x202))))))));
IkReal x209=pz*pz;
j16eval[0]=((1.0)+(((44.4503709630156)*x209)));
j16eval[1]=IKsign(((224970001.0)+(((10000000000.0)*x209))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x210=gconst4*gconst4;
IkReal x211=gconst5*gconst5;
IkReal x212=(gconst4*gconst5);
CheckValue<IkReal> x213 = IKatan2WithCheck(IkReal(((1690.0)+(((0.0221)*gconst4))+(((-6032.0)*gconst5))+(((7.225e-8)*x210))+(((-100000.0)*(pz*pz)))+(((-0.03944)*x212))+(((5382.4)*x211)))),IkReal(((0.01248)+(((3016.0000000816)*gconst4))+(((-0.011222)*gconst5))+(((-5382.39999992775)*x212))+(((0.01972)*x210))+(((-14999.0)*pz))+(((-0.01972)*x211)))),IKFAST_ATAN2_MAGTHRESH);
if(!x213.valid){
continue;
}
CheckValue<IkReal> x214=IKPowWithIntegerCheck(IKsign(((-1949.87)+(((23200.0)*gconst4*pz))+(((3479.768)*gconst5))+(((-0.01274915)*gconst4))+(((0.085)*gconst5*pz))+(((0.096)*pz)))),-1);
if(!x214.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x213.value)+(((1.5707963267949)*(x214.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x215=IKcos(j16);
IkReal x216=IKsin(j16);
IkReal x217=((8.5e-7)*gconst5);
IkReal x218=((0.232)*gconst4);
IkReal x219=((8.5e-7)*gconst4);
IkReal x220=((0.232)*gconst5);
IkReal x221=((0.232)*x216);
IkReal x222=(pz*x216);
IkReal x223=(pz*x215);
evalcond[0]=((-0.13)+x220+x223+(((-1.0)*x219))+(((-0.14999)*x216)));
evalcond[1]=((9.6e-7)+x217+x218+x222+(((0.14999)*x215)));
evalcond[2]=((0.0172892498998009)+(((-0.0389974)*x216))+(((-1.0)*(pz*pz)))+(((0.26)*x223))+(((-1.92e-6)*x222))+(((-2.879808e-7)*x215)));
evalcond[3]=(((x215*x220))+((x216*x217))+((x216*x218))+pz+(((-0.13)*x215))+(((9.6e-7)*x216))+(((-1.0)*x215*x219)));
evalcond[4]=((-0.14999)+((x216*x220))+(((-9.6e-7)*x215))+(((-0.13)*x216))+(((-1.0)*x216*x219))+(((-1.0)*x215*x218))+(((-1.0)*x215*x217)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
j15array[0]=0;
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x224=(gconst4*pz);
IkReal x225=(gconst5*pz);
CheckValue<IkReal> x226=IKPowWithIntegerCheck(IKsign(((224970001.0)+(((10000000000.0)*(pz*pz))))),-1);
if(!x226.valid){
continue;
}
CheckValue<IkReal> x227 = IKatan2WithCheck(IkReal(((-194987000.0)+(((-2320000000.0)*x224))+(((347976800.0)*gconst5))+(((-8500.0)*x225))+(((-9600.0)*pz))+(((-1274.915)*gconst4)))),IkReal(((-1439.904)+(((-2320000000.0)*x225))+(((8500.0)*x224))+(((-347976800.0)*gconst4))+(((1300000000.0)*pz))+(((-1274.915)*gconst5)))),IKFAST_ATAN2_MAGTHRESH);
if(!x227.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x226.value)))+(x227.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x228=IKcos(j16);
IkReal x229=IKsin(j16);
IkReal x230=((8.5e-7)*gconst5);
IkReal x231=((0.232)*gconst4);
IkReal x232=((8.5e-7)*gconst4);
IkReal x233=((0.232)*gconst5);
IkReal x234=((0.232)*x229);
IkReal x235=(pz*x229);
IkReal x236=(pz*x228);
evalcond[0]=((-0.13)+(((-0.14999)*x229))+(((-1.0)*x232))+x233+x236);
evalcond[1]=((9.6e-7)+x230+x231+x235+(((0.14999)*x228)));
evalcond[2]=((0.0172892498998009)+(((-2.879808e-7)*x228))+(((-1.0)*(pz*pz)))+(((0.26)*x236))+(((-0.0389974)*x229))+(((-1.92e-6)*x235)));
evalcond[3]=((((9.6e-7)*x229))+((x229*x231))+((x229*x230))+((x228*x233))+(((-0.13)*x228))+pz+(((-1.0)*x228*x232)));
evalcond[4]=((-0.14999)+((x229*x233))+(((-0.13)*x229))+(((-1.0)*x229*x232))+(((-9.6e-7)*x228))+(((-1.0)*x228*x230))+(((-1.0)*x228*x231)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
j15array[0]=0;
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x237=((272941.176470588)+(((6.66711114074272)*pz)));
IkReal x238=((-1.0)+(((1819729.15841448)*pz)));
IkReal x239=((-152941.176470588)+(((7.52991375895648)*pz)));
if((((74496885814.1488)+(((3311414210028.33)*(pz*pz))))) < -0.00001)
continue;
IkReal x240=IKabs(IKsqrt(((74496885814.1488)+(((3311414210028.33)*(pz*pz))))));
IkReal x241=((x238*x238)+(x237*x237));
CheckValue<IkReal> x247=IKPowWithIntegerCheck(x240,-1);
if(!x247.valid){
continue;
}
IkReal x242=x247.value;
IkReal x248 = x241;
if(IKabs(x248)==0){
continue;
}
IkReal x243=pow(x248,-0.5);
if((((1.0)+(((-1.0)*(x239*x239)*(x242*x242))))) < -0.00001)
continue;
IkReal x244=IKsqrt(((1.0)+(((-1.0)*(x239*x239)*(x242*x242)))));
IkReal x245=(x239*x242*x243);
IkReal x246=(x243*x244);
if((x241) < -0.00001)
continue;
CheckValue<IkReal> x249=IKPowWithIntegerCheck(IKabs(IKsqrt(x241)),-1);
if(!x249.valid){
continue;
}
if( ((x239*(x249.value))) < -1-IKFAST_SINCOS_THRESH || ((x239*(x249.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x250 = IKatan2WithCheck(IkReal(x237),IkReal(x238),IKFAST_ATAN2_MAGTHRESH);
if(!x250.valid){
continue;
}
IkReal gconst6=((((-1.0)*(IKasin((x239*(x249.value))))))+(((-1.0)*(x250.value))));
IkReal gconst7=((((-1.0)*x237*x246))+(((-1.0)*x238*x245)));
IkReal gconst8=((((-1.0)*x237*x245))+((x238*x246)));
if((((74496885814.1488)+(((3311414210028.33)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x252=IKPowWithIntegerCheck(IKabs(IKsqrt(((74496885814.1488)+(((3311414210028.33)*(pz*pz)))))),-1);
if(!x252.valid){
continue;
}
IkReal x251=x252.value;
CheckValue<IkReal> x253 = IKatan2WithCheck(IkReal(((272941.176470588)+(((6.66711114074272)*pz)))),IkReal(((-1.0)+(((1819729.15841448)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x253.valid){
continue;
}
if( (((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))) < -1-IKFAST_SINCOS_THRESH || (((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x254 = IKatan2WithCheck(IkReal(((272941.176470588)+(((6.66711114074272)*pz)))),IkReal(((-1.0)+(((1819729.15841448)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x254.valid){
continue;
}
if( (((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))) < -1-IKFAST_SINCOS_THRESH || (((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x255 = IKatan2WithCheck(IkReal(((272941.176470588)+(((6.66711114074272)*pz)))),IkReal(((-1.0)+(((1819729.15841448)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x255.valid){
continue;
}
CheckValue<IkReal> x256 = IKatan2WithCheck(IkReal(((272941.176470588)+(((6.66711114074272)*pz)))),IkReal(((-1.0)+(((1819729.15841448)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x256.valid){
continue;
}
if( (((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))) < -1-IKFAST_SINCOS_THRESH || (((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( (((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))) < -1-IKFAST_SINCOS_THRESH || (((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( (((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))) < -1-IKFAST_SINCOS_THRESH || (((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x257 = IKatan2WithCheck(IkReal(((272941.176470588)+(((6.66711114074272)*pz)))),IkReal(((-1.0)+(((1819729.15841448)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x257.valid){
continue;
}
if( (((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))) < -1-IKFAST_SINCOS_THRESH || (((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x258 = IKatan2WithCheck(IkReal(((272941.176470588)+(((6.66711114074272)*pz)))),IkReal(((-1.0)+(((1819729.15841448)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x258.valid){
continue;
}
if(((((j17*(x253.value)))+((j17*(IKasin(((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))))))+(((x254.value)*(IKasin(((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))))))+((j17*(j17)))+(((x255.value)*(x256.value)))+(((IKasin(((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))))*(IKasin(((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))))))+(((IKasin(((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))))*(j17)))+(((x257.value)*(j17)))+(((IKasin(((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))))*(x258.value))))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt((((j17*(x253.value)))+((j17*(IKasin(((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))))))+(((x254.value)*(IKasin(((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))))))+((j17*(j17)))+(((x255.value)*(x256.value)))+(((IKasin(((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))))*(IKasin(((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))))))+(((IKasin(((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))))*(j17)))+(((x257.value)*(j17)))+(((IKasin(((((-152941.176470588)*x251))+(((7.52991375895648)*pz*x251)))))*(x258.value))))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[2];
IkReal x259=((6.66711114074272)*pz);
IkReal x260=pz*pz;
IkReal x261=((272941.176470588)+x259);
IkReal x262=((-1.0)+(((1819729.15841448)*pz)));
IkReal x263=((-152941.176470588)+(((7.52991375895648)*pz)));
IkReal x264=x240;
IkReal x265=((x262*x262)+(x261*x261));
CheckValue<IkReal> x272=IKPowWithIntegerCheck(x264,-1);
if(!x272.valid){
continue;
}
IkReal x266=x272.value;
IkReal x273 = x265;
if(IKabs(x273)==0){
continue;
}
IkReal x267=pow(x273,-0.5);
if((x265) < -0.00001)
continue;
CheckValue<IkReal> x274=IKPowWithIntegerCheck(IKabs(IKsqrt(x265)),-1);
if(!x274.valid){
continue;
}
IkReal x268=x274.value;
if((((1.0)+(((-1.0)*(x263*x263)*(x266*x266))))) < -0.00001)
continue;
IkReal x269=IKsqrt(((1.0)+(((-1.0)*(x263*x263)*(x266*x266)))));
IkReal x270=(x263*x266*x267);
IkReal x271=(x267*x269);
px=0;
py=0;
pp=x260;
sj17=gconst7;
cj17=gconst8;
CheckValue<IkReal> x275 = IKatan2WithCheck(IkReal(((273224.043715847)+x259)),IkReal(((-1.0)+(((1818181.81818182)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x275.valid){
continue;
}
if( ((x268*(((-152905.198776758)+(((7.52991352270815)*pz)))))) < -1-IKFAST_SINCOS_THRESH || ((x268*(((-152905.198776758)+(((7.52991352270815)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j17=((((-1.0)*(x275.value)))+(((-1.0)*(IKasin((x268*(((-152905.198776758)+(((7.52991352270815)*pz))))))))));
CheckValue<IkReal> x276 = IKatan2WithCheck(IkReal(x261),IkReal(x262),IKFAST_ATAN2_MAGTHRESH);
if(!x276.valid){
continue;
}
if( ((x263*x268)) < -1-IKFAST_SINCOS_THRESH || ((x263*x268)) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst6=((((-1.0)*(x276.value)))+(((-1.0)*(IKasin((x263*x268))))));
IkReal gconst7=((((-1.0)*x262*x270))+(((-1.0)*x261*x271)));
IkReal gconst8=(((x262*x271))+(((-1.0)*x261*x270)));
IkReal x277=pz*pz;
j16eval[0]=((1.0)+(((44.4503709630156)*x277)));
j16eval[1]=IKsign(((224970001.0)+(((10000000000.0)*x277))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x278=gconst7*gconst7;
IkReal x279=gconst8*gconst8;
IkReal x280=(gconst7*gconst8);
CheckValue<IkReal> x281 = IKatan2WithCheck(IkReal(((0.01248)+(((-5382.39999992775)*x280))+(((3016.0000000816)*gconst7))+(((0.01972)*x278))+(((-0.011222)*gconst8))+(((-0.01972)*x279))+(((14999.0)*pz)))),IkReal(((9.216e-8)+(((5382.4)*x278))+(((7.225e-8)*x279))+(((1.632e-7)*gconst8))+(((-100000.0)*(pz*pz)))+(((0.03944)*x280))+(((0.044544)*gconst7)))),IKFAST_ATAN2_MAGTHRESH);
if(!x281.valid){
continue;
}
CheckValue<IkReal> x282=IKPowWithIntegerCheck(IKsign(((-0.01439904)+(((-3479.768)*gconst7))+(((-0.01274915)*gconst8))+(((-13000.0)*pz))+(((23200.0)*gconst8*pz))+(((-0.085)*gconst7*pz)))),-1);
if(!x282.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x281.value)+(((1.5707963267949)*(x282.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x283=IKcos(j16);
IkReal x284=IKsin(j16);
IkReal x285=((8.5e-7)*gconst7);
IkReal x286=((8.5e-7)*gconst8);
IkReal x287=((0.232)*x283);
IkReal x288=((0.232)*x284);
IkReal x289=(pz*x284);
IkReal x290=(pz*x283);
evalcond[0]=((-0.13)+x290+(((-1.0)*x285))+(((0.232)*gconst8))+(((-0.14999)*x284)));
evalcond[1]=((9.6e-7)+x289+x286+(((0.14999)*x283))+(((0.232)*gconst7)));
evalcond[2]=((0.0172892498998009)+(((-1.92e-6)*x289))+(((0.26)*x290))+(((-0.0389974)*x284))+(((-1.0)*(pz*pz)))+(((-2.879808e-7)*x283)));
evalcond[3]=(((x284*x286))+pz+((gconst8*x287))+(((9.6e-7)*x284))+((gconst7*x288))+(((-1.0)*x283*x285))+(((-0.13)*x283)));
evalcond[4]=((-0.14999)+(((-1.0)*gconst7*x287))+(((-9.6e-7)*x283))+(((-1.0)*x284*x285))+((gconst8*x288))+(((-1.0)*x283*x286))+(((-0.13)*x284)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
j15array[0]=0;
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x291=((8500.0)*pz);
IkReal x292=((2320000000.0)*pz);
CheckValue<IkReal> x293=IKPowWithIntegerCheck(IKsign(((224970001.0)+(((10000000000.0)*(pz*pz))))),-1);
if(!x293.valid){
continue;
}
CheckValue<IkReal> x294 = IKatan2WithCheck(IkReal(((-194987000.0)+(((347976800.0)*gconst8))+(((-1.0)*gconst8*x291))+(((-9600.0)*pz))+(((-1.0)*gconst7*x292))+(((-1274.915)*gconst7)))),IkReal(((-1439.904)+((gconst7*x291))+(((-1.0)*gconst8*x292))+(((-347976800.0)*gconst7))+(((1300000000.0)*pz))+(((-1274.915)*gconst8)))),IKFAST_ATAN2_MAGTHRESH);
if(!x294.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x293.value)))+(x294.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x295=IKcos(j16);
IkReal x296=IKsin(j16);
IkReal x297=((8.5e-7)*gconst7);
IkReal x298=((8.5e-7)*gconst8);
IkReal x299=((0.232)*x295);
IkReal x300=((0.232)*x296);
IkReal x301=(pz*x296);
IkReal x302=(pz*x295);
evalcond[0]=((-0.13)+(((-1.0)*x297))+(((-0.14999)*x296))+x302+(((0.232)*gconst8)));
evalcond[1]=((9.6e-7)+(((0.14999)*x295))+x301+x298+(((0.232)*gconst7)));
evalcond[2]=((0.0172892498998009)+(((-1.92e-6)*x301))+(((0.26)*x302))+(((-2.879808e-7)*x295))+(((-1.0)*(pz*pz)))+(((-0.0389974)*x296)));
evalcond[3]=(((gconst8*x299))+(((9.6e-7)*x296))+(((-0.13)*x295))+pz+(((-1.0)*x295*x297))+((x296*x298))+((gconst7*x300)));
evalcond[4]=((-0.14999)+((gconst8*x300))+(((-1.0)*x296*x297))+(((-0.13)*x296))+(((-1.0)*x295*x298))+(((-1.0)*gconst7*x299))+(((-9.6e-7)*x295)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
j15array[0]=0;
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x303=((272941.176470588)+(((6.66711114074272)*pz)));
IkReal x304=((-1.0)+(((1819729.15841448)*pz)));
IkReal x305=((-152941.176470588)+(((7.52991375895648)*pz)));
if((((74496885814.1488)+(((3311414210028.33)*(pz*pz))))) < -0.00001)
continue;
IkReal x306=IKabs(IKsqrt(((74496885814.1488)+(((3311414210028.33)*(pz*pz))))));
IkReal x307=((x303*x303)+(x304*x304));
CheckValue<IkReal> x314=IKPowWithIntegerCheck(x306,-1);
if(!x314.valid){
continue;
}
IkReal x308=x314.value;
IkReal x309=(x305*x308);
IkReal x315 = x307;
if(IKabs(x315)==0){
continue;
}
IkReal x310=pow(x315,-0.5);
IkReal x311=((1.0)*x303*x310);
IkReal x312=((1.0)*x304*x310);
if((((1.0)+(((-1.0)*(x309*x309))))) < -0.00001)
continue;
IkReal x313=IKsqrt(((1.0)+(((-1.0)*(x309*x309)))));
if((x307) < -0.00001)
continue;
CheckValue<IkReal> x316=IKPowWithIntegerCheck(IKabs(IKsqrt(x307)),-1);
if(!x316.valid){
continue;
}
if( ((x305*(x316.value))) < -1-IKFAST_SINCOS_THRESH || ((x305*(x316.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x317 = IKatan2WithCheck(IkReal(x303),IkReal(x304),IKFAST_ATAN2_MAGTHRESH);
if(!x317.valid){
continue;
}
IkReal gconst9=((3.14159265358979)+(IKasin((x305*(x316.value))))+(((-1.0)*(x317.value))));
IkReal gconst10=(((x311*x313))+(((-1.0)*x309*x312)));
IkReal gconst11=((((-1.0)*x312*x313))+(((-1.0)*x309*x311)));
IkReal x318=((272941.176470588)+(((6.66711114074272)*pz)));
IkReal x319=((-1.0)+(((1819729.15841448)*pz)));
if((((x319*x319)+(x318*x318))) < -0.00001)
continue;
CheckValue<IkReal> x320=IKPowWithIntegerCheck(IKabs(IKsqrt(((x319*x319)+(x318*x318)))),-1);
if(!x320.valid){
continue;
}
if( (((x320.value)*(((-152941.176470588)+(((7.52991375895648)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x320.value)*(((-152941.176470588)+(((7.52991375895648)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x321 = IKatan2WithCheck(IkReal(x318),IkReal(x319),IKFAST_ATAN2_MAGTHRESH);
if(!x321.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(((-1.0)*(IKasin(((x320.value)*(((-152941.176470588)+(((7.52991375895648)*pz)))))))))+j17+(x321.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[2];
IkReal x322=((6.66711114074272)*pz);
IkReal x323=pz*pz;
IkReal x324=((272941.176470588)+x322);
IkReal x325=((-1.0)+(((1819729.15841448)*pz)));
IkReal x326=((-152941.176470588)+(((7.52991375895648)*pz)));
IkReal x327=x306;
IkReal x328=((x325*x325)+(x324*x324));
CheckValue<IkReal> x336=IKPowWithIntegerCheck(x327,-1);
if(!x336.valid){
continue;
}
IkReal x329=x336.value;
IkReal x330=(x326*x329);
IkReal x337 = x328;
if(IKabs(x337)==0){
continue;
}
IkReal x331=pow(x337,-0.5);
if((x328) < -0.00001)
continue;
CheckValue<IkReal> x338=IKPowWithIntegerCheck(IKabs(IKsqrt(x328)),-1);
if(!x338.valid){
continue;
}
IkReal x332=x338.value;
IkReal x333=((1.0)*x324*x331);
IkReal x334=((1.0)*x325*x331);
if((((1.0)+(((-1.0)*(x330*x330))))) < -0.00001)
continue;
IkReal x335=IKsqrt(((1.0)+(((-1.0)*(x330*x330)))));
px=0;
py=0;
pp=x323;
sj17=gconst10;
cj17=gconst11;
if( ((x332*(((-152905.198776758)+(((7.52991352270815)*pz)))))) < -1-IKFAST_SINCOS_THRESH || ((x332*(((-152905.198776758)+(((7.52991352270815)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x339 = IKatan2WithCheck(IkReal(((273224.043715847)+x322)),IkReal(((-1.0)+(((1818181.81818182)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x339.valid){
continue;
}
j17=((3.14159265)+(IKasin((x332*(((-152905.198776758)+(((7.52991352270815)*pz)))))))+(((-1.0)*(x339.value))));
CheckValue<IkReal> x340 = IKatan2WithCheck(IkReal(x324),IkReal(x325),IKFAST_ATAN2_MAGTHRESH);
if(!x340.valid){
continue;
}
if( ((x326*x332)) < -1-IKFAST_SINCOS_THRESH || ((x326*x332)) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst9=((3.14159265358979)+(((-1.0)*(x340.value)))+(IKasin((x326*x332))));
IkReal gconst10=((((-1.0)*x330*x334))+((x333*x335)));
IkReal gconst11=((((-1.0)*x330*x333))+(((-1.0)*x334*x335)));
IkReal x341=pz*pz;
j16eval[0]=((1.0)+(((44.4503709630156)*x341)));
j16eval[1]=IKsign(((224970001.0)+(((10000000000.0)*x341))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x342=gconst10*gconst10;
IkReal x343=gconst11*gconst11;
IkReal x344=(gconst10*gconst11);
CheckValue<IkReal> x345=IKPowWithIntegerCheck(IKsign(((-1949.87)+(((3479.768)*gconst11))+(((23200.0)*gconst10*pz))+(((0.096)*pz))+(((-0.01274915)*gconst10))+(((0.085)*gconst11*pz)))),-1);
if(!x345.valid){
continue;
}
CheckValue<IkReal> x346 = IKatan2WithCheck(IkReal(((1690.0)+(((7.225e-8)*x342))+(((0.0221)*gconst10))+(((-100000.0)*(pz*pz)))+(((-6032.0)*gconst11))+(((-0.03944)*x344))+(((5382.4)*x343)))),IkReal(((0.01248)+(((-0.01972)*x343))+(((3016.0000000816)*gconst10))+(((-0.011222)*gconst11))+(((-5382.39999992775)*x344))+(((-14999.0)*pz))+(((0.01972)*x342)))),IKFAST_ATAN2_MAGTHRESH);
if(!x346.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x345.value)))+(x346.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x347=IKcos(j16);
IkReal x348=IKsin(j16);
IkReal x349=((0.232)*gconst10);
IkReal x350=((8.5e-7)*gconst11);
IkReal x351=((0.232)*gconst11);
IkReal x352=((8.5e-7)*gconst10);
IkReal x353=(pz*x348);
IkReal x354=(pz*x347);
evalcond[0]=((-0.13)+(((-0.14999)*x348))+(((-1.0)*x352))+x351+x354);
evalcond[1]=((9.6e-7)+(((0.14999)*x347))+x350+x353+x349);
evalcond[2]=((0.0172892498998009)+(((-0.0389974)*x348))+(((-1.0)*(pz*pz)))+(((-2.879808e-7)*x347))+(((0.26)*x354))+(((-1.92e-6)*x353)));
evalcond[3]=(((x348*x349))+(((9.6e-7)*x348))+((x347*x351))+pz+(((-1.0)*x347*x352))+((x348*x350))+(((-0.13)*x347)));
evalcond[4]=((-0.14999)+(((-1.0)*x348*x352))+(((-9.6e-7)*x347))+(((-1.0)*x347*x349))+(((-1.0)*x347*x350))+((x348*x351))+(((-0.13)*x348)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
j15array[0]=0;
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x355=(gconst10*pz);
IkReal x356=(gconst11*pz);
CheckValue<IkReal> x357 = IKatan2WithCheck(IkReal(((-194987000.0)+(((-1274.915)*gconst10))+(((-8500.0)*x356))+(((-9600.0)*pz))+(((-2320000000.0)*x355))+(((347976800.0)*gconst11)))),IkReal(((-1439.904)+(((-1274.915)*gconst11))+(((8500.0)*x355))+(((-2320000000.0)*x356))+(((1300000000.0)*pz))+(((-347976800.0)*gconst10)))),IKFAST_ATAN2_MAGTHRESH);
if(!x357.valid){
continue;
}
CheckValue<IkReal> x358=IKPowWithIntegerCheck(IKsign(((224970001.0)+(((10000000000.0)*(pz*pz))))),-1);
if(!x358.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x357.value)+(((1.5707963267949)*(x358.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x359=IKcos(j16);
IkReal x360=IKsin(j16);
IkReal x361=((0.232)*gconst10);
IkReal x362=((8.5e-7)*gconst11);
IkReal x363=((0.232)*gconst11);
IkReal x364=((8.5e-7)*gconst10);
IkReal x365=(pz*x360);
IkReal x366=(pz*x359);
evalcond[0]=((-0.13)+(((-1.0)*x364))+x363+x366+(((-0.14999)*x360)));
evalcond[1]=((9.6e-7)+x361+x362+x365+(((0.14999)*x359)));
evalcond[2]=((0.0172892498998009)+(((-0.0389974)*x360))+(((-1.92e-6)*x365))+(((-2.879808e-7)*x359))+(((-1.0)*(pz*pz)))+(((0.26)*x366)));
evalcond[3]=(((x359*x363))+(((-0.13)*x359))+pz+(((-1.0)*x359*x364))+((x360*x362))+((x360*x361))+(((9.6e-7)*x360)));
evalcond[4]=((-0.14999)+(((-1.0)*x360*x364))+(((-0.13)*x360))+(((-9.6e-7)*x359))+(((-1.0)*x359*x362))+(((-1.0)*x359*x361))+((x360*x363)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
j15array[0]=0;
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j15, j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x367=cj17*cj17;
IkReal x368=(cj17*sj17);
CheckValue<IkReal> x369 = IKatan2WithCheck(IkReal(((0.0322)+(((-0.03944)*x367))+(((3016.0000000816)*sj17))+(((-0.011222)*cj17))+(((-5382.39999992775)*x368))+(((14999.0)*pz)))),IkReal(((5382.40000009216)+(((0.044544)*sj17))+(((-100000.0)*(pz*pz)))+(((0.03944)*x368))+(((-5382.39999992775)*x367))+(((1.632e-7)*cj17)))),IKFAST_ATAN2_MAGTHRESH);
if(!x369.valid){
continue;
}
CheckValue<IkReal> x370=IKPowWithIntegerCheck(IKsign(((-0.01439904)+(((23200.0)*cj17*pz))+(((-0.085)*pz*sj17))+(((-13000.0)*pz))+(((-3479.768)*sj17))+(((-0.01274915)*cj17)))),-1);
if(!x370.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x369.value)+(((1.5707963267949)*(x370.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x371=IKcos(j16);
IkReal x372=IKsin(j16);
IkReal x373=((0.232)*cj17);
IkReal x374=((0.232)*sj17);
IkReal x375=((8.5e-7)*sj17);
IkReal x376=((8.5e-7)*cj17);
IkReal x377=((8.5e-7)*x372);
IkReal x378=(pz*x372);
IkReal x379=(pz*x371);
evalcond[0]=((-0.13)+(((-0.14999)*x372))+(((-1.0)*x375))+x379+x373);
evalcond[1]=((9.6e-7)+x378+x376+x374+(((0.14999)*x371)));
evalcond[2]=((0.0172892498998009)+(((-0.0389974)*x372))+(((-1.92e-6)*x378))+(((-1.0)*(pz*pz)))+(((-2.879808e-7)*x371))+(((0.26)*x379)));
evalcond[3]=((((9.6e-7)*x372))+((x372*x376))+((x372*x374))+(((-0.13)*x371))+pz+(((-1.0)*x371*x375))+((x371*x373)));
evalcond[4]=((-0.14999)+(((-1.0)*x372*x375))+((x372*x373))+(((-0.13)*x372))+(((-1.0)*x371*x374))+(((-1.0)*x371*x376))+(((-9.6e-7)*x371)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
j15array[0]=0;
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x380=cj17*cj17;
IkReal x381=(cj17*sj17);
CheckValue<IkReal> x382=IKPowWithIntegerCheck(IKsign(((-1949.87)+(((23200.0)*pz*sj17))+(((3479.768)*cj17))+(((-0.01274915)*sj17))+(((0.085)*cj17*pz))+(((0.096)*pz)))),-1);
if(!x382.valid){
continue;
}
CheckValue<IkReal> x383 = IKatan2WithCheck(IkReal(((1690.00000007225)+(((5382.39999992775)*x380))+(((-0.03944)*x381))+(((-6032.0)*cj17))+(((-100000.0)*(pz*pz)))+(((0.0221)*sj17)))),IkReal(((0.0322)+(((3016.0000000816)*sj17))+(((-0.03944)*x380))+(((-5382.39999992775)*x381))+(((-0.011222)*cj17))+(((-14999.0)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x383.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x382.value)))+(x383.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x384=IKcos(j16);
IkReal x385=IKsin(j16);
IkReal x386=((0.232)*cj17);
IkReal x387=((0.232)*sj17);
IkReal x388=((8.5e-7)*sj17);
IkReal x389=((8.5e-7)*cj17);
IkReal x390=((8.5e-7)*x385);
IkReal x391=(pz*x385);
IkReal x392=(pz*x384);
evalcond[0]=((-0.13)+(((-0.14999)*x385))+x386+x392+(((-1.0)*x388)));
evalcond[1]=((9.6e-7)+(((0.14999)*x384))+x387+x389+x391);
evalcond[2]=((0.0172892498998009)+(((-0.0389974)*x385))+(((-2.879808e-7)*x384))+(((-1.92e-6)*x391))+(((-1.0)*(pz*pz)))+(((0.26)*x392)));
evalcond[3]=((((-0.13)*x384))+((x384*x386))+(((-1.0)*x384*x388))+(((9.6e-7)*x385))+pz+((x385*x389))+((x385*x387)));
evalcond[4]=((-0.14999)+(((-0.13)*x385))+(((-9.6e-7)*x384))+(((-1.0)*x384*x387))+(((-1.0)*x384*x389))+((x385*x386))+(((-1.0)*x385*x388)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
j15array[0]=0;
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x393=((8500.0)*pz);
IkReal x394=((2320000000.0)*pz);
CheckValue<IkReal> x395=IKPowWithIntegerCheck(IKsign(((224970001.0)+(((10000000000.0)*(pz*pz))))),-1);
if(!x395.valid){
continue;
}
CheckValue<IkReal> x396 = IKatan2WithCheck(IkReal(((-194987000.0)+(((-1.0)*cj17*x393))+(((-1274.915)*sj17))+(((-9600.0)*pz))+(((347976800.0)*cj17))+(((-1.0)*sj17*x394)))),IkReal(((-1439.904)+(((-1.0)*cj17*x394))+((sj17*x393))+(((-347976800.0)*sj17))+(((-1274.915)*cj17))+(((1300000000.0)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x396.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x395.value)))+(x396.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x397=IKcos(j16);
IkReal x398=IKsin(j16);
IkReal x399=((0.232)*cj17);
IkReal x400=((0.232)*sj17);
IkReal x401=((8.5e-7)*sj17);
IkReal x402=((8.5e-7)*cj17);
IkReal x403=((8.5e-7)*x398);
IkReal x404=(pz*x398);
IkReal x405=(pz*x397);
evalcond[0]=((-0.13)+x399+x405+(((-0.14999)*x398))+(((-1.0)*x401)));
evalcond[1]=((9.6e-7)+x400+x402+x404+(((0.14999)*x397)));
evalcond[2]=((0.0172892498998009)+(((0.26)*x405))+(((-0.0389974)*x398))+(((-1.0)*(pz*pz)))+(((-2.879808e-7)*x397))+(((-1.92e-6)*x404)));
evalcond[3]=((((-0.13)*x397))+pz+((x397*x399))+(((-1.0)*x397*x401))+((x398*x402))+((x398*x400))+(((9.6e-7)*x398)));
evalcond[4]=((-0.14999)+((x398*x399))+(((-0.13)*x398))+(((-1.0)*x398*x401))+(((-1.0)*x397*x400))+(((-1.0)*x397*x402))+(((-9.6e-7)*x397)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
j15array[0]=0;
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j15, j16, j17]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j15array[2], cj15array[2], sj15array[2];
bool j15valid[2]={false};
_nj15 = 2;
CheckValue<IkReal> x408 = IKatan2WithCheck(IkReal(px),IkReal(py),IKFAST_ATAN2_MAGTHRESH);
if(!x408.valid){
continue;
}
IkReal x406=((1.0)*(x408.value));
if((((px*px)+(py*py))) < -0.00001)
continue;
CheckValue<IkReal> x409=IKPowWithIntegerCheck(IKabs(IKsqrt(((px*px)+(py*py)))),-1);
if(!x409.valid){
continue;
}
if( (((0.0535)*(x409.value))) < -1-IKFAST_SINCOS_THRESH || (((0.0535)*(x409.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x407=IKasin(((0.0535)*(x409.value)));
j15array[0]=(x407+(((-1.0)*x406)));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
j15array[1]=((3.14159265358979)+(((-1.0)*x407))+(((-1.0)*x406)));
sj15array[1]=IKsin(j15array[1]);
cj15array[1]=IKcos(j15array[1]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
if( j15array[1] > IKPI )
{
    j15array[1]-=IK2PI;
}
else if( j15array[1] < -IKPI )
{    j15array[1]+=IK2PI;
}
j15valid[1] = true;
for(int ij15 = 0; ij15 < 2; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 2; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];

{
IkReal j17array[2], cj17array[2], sj17array[2];
bool j17valid[2]={false};
_nj17 = 2;
if( (((-0.84697032327434)+(((16.5782493363067)*(px*px)))+(((4.97314323590529)*cj15*py))+(((-4.97314323590529)*px*sj15))+(((16.5782493363067)*(pz*pz)))+(((16.5782493363067)*(py*py))))) < -1-IKFAST_SINCOS_THRESH || (((-0.84697032327434)+(((16.5782493363067)*(px*px)))+(((4.97314323590529)*cj15*py))+(((-4.97314323590529)*px*sj15))+(((16.5782493363067)*(pz*pz)))+(((16.5782493363067)*(py*py))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x410=IKasin(((-0.84697032327434)+(((16.5782493363067)*(px*px)))+(((4.97314323590529)*cj15*py))+(((-4.97314323590529)*px*sj15))+(((16.5782493363067)*(pz*pz)))+(((16.5782493363067)*(py*py)))));
j17array[0]=((1.57078527838641)+(((1.0)*x410)));
sj17array[0]=IKsin(j17array[0]);
cj17array[0]=IKcos(j17array[0]);
j17array[1]=((4.7123779319762)+(((-1.0)*x410)));
sj17array[1]=IKsin(j17array[1]);
cj17array[1]=IKcos(j17array[1]);
if( j17array[0] > IKPI )
{
    j17array[0]-=IK2PI;
}
else if( j17array[0] < -IKPI )
{    j17array[0]+=IK2PI;
}
j17valid[0] = true;
if( j17array[1] > IKPI )
{
    j17array[1]-=IK2PI;
}
else if( j17array[1] < -IKPI )
{    j17array[1]+=IK2PI;
}
j17valid[1] = true;
for(int ij17 = 0; ij17 < 2; ++ij17)
{
if( !j17valid[ij17] )
{
    continue;
}
_ij17[0] = ij17; _ij17[1] = -1;
for(int iij17 = ij17+1; iij17 < 2; ++iij17)
{
if( j17valid[iij17] && IKabs(cj17array[ij17]-cj17array[iij17]) < IKFAST_SOLUTION_THRESH && IKabs(sj17array[ij17]-sj17array[iij17]) < IKFAST_SOLUTION_THRESH )
{
    j17valid[iij17]=false; _ij17[1] = iij17; break; 
}
}
j17 = j17array[ij17]; cj17 = cj17array[ij17]; sj17 = sj17array[ij17];

{
IkReal j16eval[3];
IkReal x411=cj17*cj17;
IkReal x412=(px*sj15);
IkReal x413=((0.232)*cj17);
IkReal x414=((8.5e-7)*sj17);
IkReal x415=(cj17*pz);
IkReal x416=(cj15*py);
IkReal x417=(pz*sj17);
IkReal x418=(cj17*sj17);
IkReal x419=((6.66711114074272)*sj17);
IkReal x420=((1819729.15841448)*cj17);
j16eval[0]=((152941.176470588)+(((-1.0)*x416*x420))+((x416*x419))+(((-1.0)*x412*x419))+(((-1019675.82152536)*x412))+(((-6.66711114074272)*x415))+(((-7.52991375895648)*pz))+(((-272941.176470588)*cj17))+sj17+((x412*x420))+(((-1819729.15841448)*x417))+(((1019675.82152536)*x416)));
j16eval[1]=((IKabs(((-3.22e-7)+((pz*x416))+(((-1.0)*pz*x412))+(((0.14999)*pz))+(((3.944e-7)*x411))+(((1.1222e-7)*cj17))+(((0.0538239999992775)*x418))+(((-0.030160000000816)*sj17)))))+(IKabs(((-0.0169000000007225)+(((-0.0538239999992775)*x411))+(((3.944e-7)*x418))+(pz*pz)+(((-2.21e-7)*sj17))+(((0.06032)*cj17))))));
j16eval[2]=IKsign(((0.0194987)+(((-1.0)*x412*x414))+(((-0.03479768)*cj17))+(((-9.6e-7)*pz))+(((1.274915e-7)*sj17))+((x414*x416))+(((-0.232)*x417))+((x412*x413))+(((-1.0)*x413*x416))+(((-0.13)*x412))+(((0.13)*x416))+(((-8.5e-7)*x415))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
IkReal x421=cj17*cj17;
IkReal x422=(cj15*py);
IkReal x423=((8.5e-7)*cj17);
IkReal x424=((0.232)*sj17);
IkReal x425=(cj17*sj17);
IkReal x426=(px*sj15);
IkReal x427=(cj17*pz);
IkReal x428=(pz*sj17);
IkReal x429=((1819729.15841448)*sj17);
IkReal x430=((6.66711114074272)*cj17);
j16eval[0]=((1.12941176470588)+(((7.52991375895648)*x422))+(((6.66711114074272)*x428))+(((272941.176470588)*sj17))+(((-7.52991375895648)*x426))+cj17+(((-1.0)*x426*x429))+(((-1819729.15841448)*x427))+(((-1.0)*x426*x430))+(((1019675.82152536)*pz))+((x422*x429))+((x422*x430)));
j16eval[1]=((IKabs(((-0.0538240000009216)+(((-4.4544e-7)*sj17))+(((-1.632e-12)*cj17))+(pz*pz)+(((-3.944e-7)*x425))+(((0.0538239999992775)*x421)))))+(IKabs(((-3.22e-7)+(((-1.0)*pz*x422))+(((-0.14999)*pz))+((pz*x426))+(((3.944e-7)*x421))+(((1.1222e-7)*cj17))+(((0.0538239999992775)*x425))+(((-0.030160000000816)*sj17))))));
j16eval[2]=IKsign(((1.439904e-7)+(((1.274915e-7)*cj17))+(((0.03479768)*sj17))+(((-0.232)*x427))+(((-9.6e-7)*x426))+(((-1.0)*x424*x426))+(((-1.0)*x423*x426))+(((0.13)*pz))+((x422*x423))+((x422*x424))+(((8.5e-7)*x428))+(((9.6e-7)*x422))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[2];
j16eval[0]=((106122.08151018)+(((-90510.7736605966)*cj17))+sj17);
j16eval[1]=IKsign(((0.0707240000016441)+(((-0.060319999998368)*cj17))+(((6.6644e-7)*sj17))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j16]

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x431=(px*sj15);
IkReal x432=((0.232)*cj17);
IkReal x433=(cj15*py);
IkReal x434=((8.5e-7)*cj17);
IkReal x435=((0.232)*sj17);
IkReal x436=((8.5e-7)*sj17);
CheckValue<IkReal> x437 = IKatan2WithCheck(IkReal(((-0.0194987)+(((-1.0)*x433*x436))+(((0.03479768)*cj17))+(((-1.0)*x431*x432))+(((0.13)*x431))+(((-9.6e-7)*pz))+(((-1.274915e-7)*sj17))+(((-0.13)*x433))+(((-1.0)*pz*x435))+(((-1.0)*pz*x434))+((x431*x436))+((x432*x433)))),IkReal(((-1.439904e-7)+(((-1.0)*x433*x434))+(((-1.0)*x433*x435))+((pz*x436))+(((-9.6e-7)*x433))+(((-1.0)*pz*x432))+(((-1.274915e-7)*cj17))+((x431*x435))+((x431*x434))+(((0.13)*pz))+(((9.6e-7)*x431))+(((-0.03479768)*sj17)))),IKFAST_ATAN2_MAGTHRESH);
if(!x437.valid){
continue;
}
CheckValue<IkReal> x438=IKPowWithIntegerCheck(IKsign(((0.0707240000016441)+(((-0.060319999998368)*cj17))+(((6.6644e-7)*sj17)))),-1);
if(!x438.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x437.value)+(((1.5707963267949)*(x438.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x439=IKsin(j16);
IkReal x440=IKcos(j16);
IkReal x441=(cj15*py);
IkReal x442=((0.232)*cj17);
IkReal x443=(px*sj15);
IkReal x444=((0.232)*sj17);
IkReal x445=((8.5e-7)*sj17);
IkReal x446=((8.5e-7)*cj17);
IkReal x447=((0.26)*x439);
IkReal x448=((8.5e-7)*x439);
IkReal x449=(pz*x439);
IkReal x450=(pz*x440);
IkReal x451=((1.92e-6)*x440);
evalcond[0]=((-0.13)+((x439*x443))+(((-1.0)*x445))+x442+x450+(((-0.14999)*x439))+(((-1.0)*x439*x441)));
evalcond[1]=((9.6e-7)+((x440*x441))+x449+x444+x446+(((-1.0)*x440*x443))+(((0.14999)*x440)));
evalcond[2]=(((x439*x446))+((x439*x444))+((x440*x442))+(((-0.13)*x440))+pz+(((9.6e-7)*x439))+(((-1.0)*x440*x445)));
evalcond[3]=((-0.14999)+((x439*x442))+(((-1.0)*x441))+(((-1.0)*x439*x445))+(((-0.13)*x439))+(((-9.6e-7)*x440))+x443+(((-1.0)*x440*x444))+(((-1.0)*x440*x446)));
evalcond[4]=((0.0172892498998009)+(((0.29998)*x443))+(((-1.0)*(px*px)))+(((0.26)*x450))+((x443*x451))+(((-1.0)*(pz*pz)))+(((-0.0389974)*x439))+(((-1.92e-6)*x449))+(((-0.29998)*x441))+(((-2.879808e-7)*x440))+((x443*x447))+(((-1.0)*(py*py)))+(((-1.0)*x441*x447))+(((-1.0)*x441*x451)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x452=cj17*cj17;
IkReal x453=(cj15*py);
IkReal x454=((8.5e-7)*cj17);
IkReal x455=((0.232)*sj17);
IkReal x456=(cj17*sj17);
IkReal x457=(px*sj15);
CheckValue<IkReal> x458=IKPowWithIntegerCheck(IKsign(((1.439904e-7)+(((8.5e-7)*pz*sj17))+(((1.274915e-7)*cj17))+((x453*x455))+((x453*x454))+(((9.6e-7)*x453))+(((0.03479768)*sj17))+(((-1.0)*x454*x457))+(((-1.0)*x455*x457))+(((-0.232)*cj17*pz))+(((0.13)*pz))+(((-9.6e-7)*x457)))),-1);
if(!x458.valid){
continue;
}
CheckValue<IkReal> x459 = IKatan2WithCheck(IkReal(((-3.22e-7)+(((-1.0)*pz*x453))+(((-0.14999)*pz))+(((0.0538239999992775)*x456))+((pz*x457))+(((3.944e-7)*x452))+(((1.1222e-7)*cj17))+(((-0.030160000000816)*sj17)))),IkReal(((-0.0538240000009216)+(((-4.4544e-7)*sj17))+(((-1.632e-12)*cj17))+(pz*pz)+(((-3.944e-7)*x456))+(((0.0538239999992775)*x452)))),IKFAST_ATAN2_MAGTHRESH);
if(!x459.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x458.value)))+(x459.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x460=IKsin(j16);
IkReal x461=IKcos(j16);
IkReal x462=(cj15*py);
IkReal x463=((0.232)*cj17);
IkReal x464=(px*sj15);
IkReal x465=((0.232)*sj17);
IkReal x466=((8.5e-7)*sj17);
IkReal x467=((8.5e-7)*cj17);
IkReal x468=((0.26)*x460);
IkReal x469=((8.5e-7)*x460);
IkReal x470=(pz*x460);
IkReal x471=(pz*x461);
IkReal x472=((1.92e-6)*x461);
evalcond[0]=((-0.13)+(((-0.14999)*x460))+(((-1.0)*x466))+x463+x471+((x460*x464))+(((-1.0)*x460*x462)));
evalcond[1]=((9.6e-7)+(((-1.0)*x461*x464))+((x461*x462))+(((0.14999)*x461))+x467+x465+x470);
evalcond[2]=((((-0.13)*x461))+((x461*x463))+(((9.6e-7)*x460))+pz+((x460*x467))+((x460*x465))+(((-1.0)*x461*x466)));
evalcond[3]=((-0.14999)+(((-0.13)*x460))+(((-1.0)*x460*x466))+(((-1.0)*x462))+x464+((x460*x463))+(((-1.0)*x461*x467))+(((-1.0)*x461*x465))+(((-9.6e-7)*x461)));
evalcond[4]=((0.0172892498998009)+(((-1.0)*x462*x472))+(((-1.0)*x462*x468))+(((-1.0)*(px*px)))+(((0.26)*x471))+(((0.29998)*x464))+(((-1.92e-6)*x470))+((x464*x472))+(((-0.29998)*x462))+(((-1.0)*(pz*pz)))+(((-0.0389974)*x460))+(((-1.0)*(py*py)))+((x464*x468))+(((-2.879808e-7)*x461)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x473=cj17*cj17;
IkReal x474=(px*sj15);
IkReal x475=((0.232)*cj17);
IkReal x476=((8.5e-7)*sj17);
IkReal x477=(cj15*py);
IkReal x478=(cj17*sj17);
CheckValue<IkReal> x479=IKPowWithIntegerCheck(IKsign(((0.0194987)+(((-8.5e-7)*cj17*pz))+(((-0.13)*x474))+(((-1.0)*x475*x477))+(((-0.03479768)*cj17))+(((-9.6e-7)*pz))+(((1.274915e-7)*sj17))+(((0.13)*x477))+((x474*x475))+(((-1.0)*x474*x476))+((x476*x477))+(((-0.232)*pz*sj17)))),-1);
if(!x479.valid){
continue;
}
CheckValue<IkReal> x480 = IKatan2WithCheck(IkReal(((-0.0169000000007225)+(((3.944e-7)*x478))+(pz*pz)+(((-0.0538239999992775)*x473))+(((-2.21e-7)*sj17))+(((0.06032)*cj17)))),IkReal(((-3.22e-7)+(((3.944e-7)*x473))+(((0.14999)*pz))+(((-1.0)*pz*x474))+(((0.0538239999992775)*x478))+((pz*x477))+(((1.1222e-7)*cj17))+(((-0.030160000000816)*sj17)))),IKFAST_ATAN2_MAGTHRESH);
if(!x480.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x479.value)))+(x480.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x481=IKsin(j16);
IkReal x482=IKcos(j16);
IkReal x483=(cj15*py);
IkReal x484=((0.232)*cj17);
IkReal x485=(px*sj15);
IkReal x486=((0.232)*sj17);
IkReal x487=((8.5e-7)*sj17);
IkReal x488=((8.5e-7)*cj17);
IkReal x489=((0.26)*x481);
IkReal x490=((8.5e-7)*x481);
IkReal x491=(pz*x481);
IkReal x492=(pz*x482);
IkReal x493=((1.92e-6)*x482);
evalcond[0]=((-0.13)+(((-1.0)*x487))+(((-0.14999)*x481))+((x481*x485))+x484+x492+(((-1.0)*x481*x483)));
evalcond[1]=((9.6e-7)+(((-1.0)*x482*x485))+x488+x486+x491+((x482*x483))+(((0.14999)*x482)));
evalcond[2]=((((-0.13)*x482))+((x481*x488))+((x481*x486))+pz+(((9.6e-7)*x481))+((x482*x484))+(((-1.0)*x482*x487)));
evalcond[3]=((-0.14999)+(((-9.6e-7)*x482))+(((-0.13)*x481))+(((-1.0)*x483))+(((-1.0)*x481*x487))+((x481*x484))+x485+(((-1.0)*x482*x488))+(((-1.0)*x482*x486)));
evalcond[4]=((0.0172892498998009)+(((-2.879808e-7)*x482))+((x485*x489))+(((-1.0)*(px*px)))+(((0.26)*x492))+(((-1.0)*x483*x489))+(((-0.0389974)*x481))+(((-1.92e-6)*x491))+(((-1.0)*x483*x493))+(((-1.0)*(pz*pz)))+((x485*x493))+(((-1.0)*(py*py)))+(((-0.29998)*x483))+(((0.29998)*x485)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - el_mini (06c6645d1da374635f09bbcd98eec9ea)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004a"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
